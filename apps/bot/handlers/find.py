"""Match finding handlers."""

from aiogram import F, Router
from aiogram.filters import Command
from aiogram.types import CallbackQuery, Message
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from apps.bot.api_client import api_client
from models import User, UserTopic
from models.topic import Topic

router = Router()


@router.message(Command("find"))  # type: ignore[misc]
async def cmd_find(message: Message, db: AsyncSession) -> None:
    """Handle /find command - find a conversation partner."""
    # Check if user exists and has profile
    result = await db.execute(select(User).where(User.tg_id == message.from_user.id))
    user = result.scalar_one_or_none()

    if not user:
        await message.answer("‚ùå –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å –∫–æ–º–∞–Ω–¥–æ–π /profile\n\n–≠—Ç–æ –∑–∞–π–º–µ—Ç –≤—Å–µ–≥–æ 2 –º–∏–Ω—É—Ç—ã!")
        return

    # Check if user has at least 2 topics
    result = await db.execute(select(UserTopic).where(UserTopic.user_id == user.id))
    topics_count = len(result.scalars().all())

    if topics_count < 2:
        await message.answer("‚ùå –î–æ–±–∞–≤—å—Ç–µ –º–∏–Ω–∏–º—É–º 2 —Ç–µ–º—ã –≤ –ø—Ä–æ—Ñ–∏–ª–µ\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /profile –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")
        return

    # Check if user confirmed safety rules
    if not user.safety_ack:
        await message.answer("‚ùå –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ: /profile")
        return

    # Get user's topics for the API request
    topics_result = await db.execute(select(Topic.slug).join(UserTopic).where(UserTopic.user_id == user.id))
    user_topics = topics_result.scalars().all()

    # Add user to match queue via API
    try:
        response = await api_client.post(
            "/match/find",
            json={
                "user_id": user.tg_id,  # Use tg_id as expected by API
                "topics": list(user_topics),
                "timezone": user.tz,
            },
        )
        if response.get("status") == "queued":
            await message.answer(
                "üîç –ò—â—É –¥–ª—è –≤–∞—Å —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...\n\n"
                "–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –¥–æ –º–∏–Ω—É—Ç—ã. –Ø –ø—Ä–∏—à–ª—é –≤–∞–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ–≥–¥–∞ –Ω–∞–π–¥—É –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞."
            )
        else:
            await message.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    except Exception as e:
        await message.answer("‚ö†Ô∏è –°–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        import logging

        logging.error(f"Failed to add user to match queue: {e}")


@router.callback_query(F.data.startswith("match_accept_"))  # type: ignore[misc]
async def handle_match_accept(callback: CallbackQuery, db: AsyncSession) -> None:
    """Handle match acceptance with HMAC verification and idempotency."""
    # Parse callback data: match_accept_{match_id}_{hmac}
    parts = callback.data.split("_")
    if len(parts) != 4:
        await callback.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return

    match_id = int(parts[2])
    provided_hmac = parts[3]

    # Get user from database
    result = await db.execute(select(User).where(User.tg_id == callback.from_user.id))
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    # SECURITY: Verify HMAC signature
    from core.security import verify_callback_hmac

    if not verify_callback_hmac(match_id, user.id, provided_hmac):
        await callback.answer("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
        return

    # IDEMPOTENCY: Check if already processed via Redis
    from core.redis import get_redis

    redis_client = await get_redis()
    idempotency_key = f"confirm:{callback.id}"

    # Try to set idempotency key (SETNX)
    is_first_time = await redis_client.set(idempotency_key, "1", nx=True, ex=60)

    if not is_first_time:
        await callback.answer("‚è≥ –£–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è...", show_alert=True)
        return

    try:
        # Call API to confirm match
        response = await api_client.post(
            "/match/confirm", json={"match_id": match_id, "action": "accept", "user_id": user.id}
        )

        if response.get("status") == "active":
            await callback.message.edit_text(
                "‚úÖ –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ!\n\n"
                "–ß–∞—Ç —Å–æ–∑–¥–∞–Ω. –í–∞—à —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ —Å–µ–π—á–∞—Å –ø–æ–ª—É—á–∏—Ç –∏–Ω—Ç—Ä–æ-—Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø—Ä–∞–≤–∏–ª–∞.\n\n"
                "–ë—É–¥—å—Ç–µ —É–≤–∞–∂–∏—Ç–µ–ª—å–Ω—ã –∏ –ø–æ–º–Ω–∏—Ç–µ –æ –ø—Ä–∞–≤–∏–ª–∞—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ–±—â–µ–Ω–∏—è! üíö"
            )
        elif response.get("status") == "expired":
            await callback.message.edit_text("‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /find —Å–Ω–æ–≤–∞.")
        else:
            await callback.message.edit_text("‚úÖ –í—ã –ø—Ä–∏–Ω—è–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ\n\n–û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...")
        await callback.answer()
    except Exception as e:
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
        import logging

        logging.error(f"Failed to accept match: {e}")


@router.callback_query(F.data.startswith("match_decline_"))  # type: ignore[misc]
async def handle_match_decline(callback: CallbackQuery, db: AsyncSession) -> None:
    """Handle match decline with HMAC verification and idempotency."""
    # Parse callback data: match_decline_{match_id}_{hmac}
    parts = callback.data.split("_")
    if len(parts) != 4:
        await callback.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return

    match_id = int(parts[2])
    provided_hmac = parts[3]

    # Get user from database
    result = await db.execute(select(User).where(User.tg_id == callback.from_user.id))
    user = result.scalar_one_or_none()

    if not user:
        await callback.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    # SECURITY: Verify HMAC signature
    from core.security import verify_callback_hmac

    if not verify_callback_hmac(match_id, user.id, provided_hmac):
        await callback.answer("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
        return

    # IDEMPOTENCY: Check if already processed via Redis
    from core.redis import get_redis

    redis_client = await get_redis()
    idempotency_key = f"confirm:{callback.id}"

    # Try to set idempotency key (SETNX)
    is_first_time = await redis_client.set(idempotency_key, "1", nx=True, ex=60)

    if not is_first_time:
        await callback.answer("‚è≥ –£–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è...", show_alert=True)
        return

    try:
        # Call API to decline match
        response = await api_client.post(
            "/match/confirm", json={"match_id": match_id, "action": "decline", "user_id": user.id}
        )

        if response.get("status") == "declined":
            await callback.message.edit_text(
                "üëå –•–æ—Ä–æ—à–æ, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞.\n\n–ü—Ä–æ–¥–æ–ª–∂–∞—é –∏—Å–∫–∞—Ç—å –¥–ª—è –≤–∞—Å –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞..."
            )
        await callback.answer()
    except Exception as e:
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
        import logging

        logging.error(f"Failed to decline match: {e}")
